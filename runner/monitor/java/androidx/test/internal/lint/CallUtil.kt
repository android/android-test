/*
 * Copyright (C) 2022 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package third_party.android.androidx_test.runner.monitor.java.androidx.test.internal.lint

import com.android.tools.lint.detector.api.UastCallVisitor
import com.android.tools.lint.detector.api.getUMethod
import com.intellij.psi.PsiMethod
import com.intellij.psi.PsiSubstitutor
import com.intellij.psi.PsiType
import com.intellij.psi.util.MethodSignature
import java.util.LinkedList
import java.util.Queue
import org.jetbrains.uast.UCallExpression
import org.jetbrains.uast.UElement
import org.jetbrains.uast.ULambdaExpression

/**
 * Starting from a given UAST element, iteratively search the call graph to identify function
 * calls by matching method signatures.
 * @receiver The UElement to start the search from.
 * @param sinkMethodSignature The method signature of the target function call to be searched;
 * generated by PsiMethod.getMethodSignature.
 * @param maxDepth The maximum depth of call graph to be searched.
 * @return A list of UElement containing all matched function calls.
 */
fun UElement.searchCall(sinkMethodSignature: String, maxDepth: Int): List<UCallExpression> {
  val callNodes: MutableList<UCallExpression> = arrayListOf()
  val workQueue: Queue<Pair<UElement, Int>> = LinkedList()

  workQueue.add(Pair(this, 0))
  while (!workQueue.isEmpty()) {
    val pair = workQueue.remove()
    val startNode = pair.first
    val depth = pair.second
    if (depth > maxDepth) {
      continue
    }
    val visitor =
      object : UastCallVisitor() {
        override fun visitCall(node: UCallExpression): Boolean {
          System.err.println(node.toString())
          node.resolve()?.let {
            if (it.getMethodSignature() == sinkMethodSignature) {
              callNodes.add(node)
            } else {
              it.getUMethod()?.let { nextMethod -> workQueue.add(Pair(nextMethod, depth + 1)) }
            }
          }
          return true
        }

        override fun visitLambdaExpression(node: ULambdaExpression): Boolean {
          return if (node !== startNode) {
            workQueue.add(Pair(node, depth + 1))
            true
          } else {
            false
          }
        }
      }
    startNode.accept(visitor = visitor)
  }
  return callNodes
}

/** Generate a String readable method signature given a PsiMethod object. */
fun PsiMethod.getMethodSignature(): String {
  val signatureObject: MethodSignature = this.getSignature(PsiSubstitutor.EMPTY)
  val className: String = this.containingClass?.qualifiedName ?: ""
  val methodName: String = signatureObject.name
  val parameterNames: MutableList<String> = arrayListOf()
  for (parameterType: PsiType in signatureObject.parameterTypes) {
    parameterNames.add(parameterType.getCanonicalText(false))
  }
  val parameterString = parameterNames.joinToString(separator = ",")
  return "$className::$methodName($parameterString)"
}
